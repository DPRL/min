\documentclass[letterpaper]{article}
\pagestyle{empty}

\usepackage{alltt}

\begin{document}

\author{Christopher Sasarak}
\title{Summary of Min Refactor}

\maketitle

\section*{How to Read this Document}


I will refer to the version of Min with the old events system as 'Min Classic'.
When I make reference to just Min, I am referring to the latest version in the
master branch and on http://saskatoon.cs.rit.edu/min.

Min Classic by checking out the tag \verb+min_classic+ from the git repository:
\begin{verbatim} git checkout min_classic \end{verbatim} You can checkout Min by
using \begin{verbatim} git checkout master \end{verbatim}.

I will also make reference to 'editing modes' in both Min and Min Classic.
When I refer to an editing mode, I am referring to a state of the editor that is
visible by the user. For example, when the pen icon is shaded and the user can
draw/type symbols into the system I will refer to it as 'pen mode'.

\section*{Event System Descriptions}

\subsection*{Min Classic Event System} 
Most of the events used by Min Classic are stored in the \verb+Editor.Events.js+ file. 
The listeners for buttons are bound in \verb+Editor.setup_events+ and will not
change for the life of the running Min instance. These button events are moved
and remained, but are mostly unaltered between Min Classic and the refactored
version. Likewise, events related to \verb+keypress+ events are largely the
same in Min; aside from being bound in different places/times. The Hammer events
used for the multi-touch pinch-to-resize functionality are moved, but also largely
unchanged.

The following events are bound to the \verb+equation_canvas+ div and set to trigger
on their respective actions:
\verb+Editor.onMouseDown+, \verb+Editor.onMouseMove+,
\verb+Editor.onMouseUp+, \verb+Editor.onDoubleClick+. These events are
responsible for drawing, selecting segments, moving segments, and resizing
segments, i.e. the vast majority of user interaction. 

Because of the UI's complexity, and the limited number of possible input
methods, the same actions must be perform different behaviors based on the
editor's state. In Min Classic, the state was maintained by having a global
enumeration object declared in \verb+Editor.Events.js+ called \verb+EditorState+.
As the system runs, the currently running state is maintained in the variable
Editor.state. Editor states do no necessarily correspond directly to modes, it
is possible for an editor mode to make use of multiple editor states. 

Because the Javascript events bound to the \verb+equation_canvas+ div are never
changed for the life of a Min session, they each contain a switch statement
which determines which of their possible behaviors to use. The case to use is
selected by the current Editor state.

One weakness of this system is that the programmer must make sure that she sets
the Editor.state variable appropriately when adding new functionality. Doing
this incorrectly means that Min Classic could exhibit behavior appropriate for
other states. Additionally, it can be very difficult to locate where bugs are.
For example, to fix a bug in draw mode, the programmer might also have to look
at the code pertaining to the other modes rather than just draw mode.  

\subsection*{New Event System}

In order to address some of the shortcomings of the old event system, the DPRL
designed and implemented a new one which tries to handle the complexity of Min
with a (hopefully) cleaner approach. The main goals of this refactoring were:

\begin{enumerate}
    \item To make Min easier to hack for newcomers.  
    \item To make it easier to identify where bugs are caused.
    \item To separate concerns in the event system.
    \item To eliminate the use of EditorState as much as possible.
\end{enumerate}

The new Min event system is designed under the idea that the functionality of
Min can be separated into several discrete modes: Draw Mode, Stroke Selection
Mode, and Rectangle Selection mode. By keeping track of the modes, we know which
functionality should be active and which should not be. Thus the user switches
from one mode to another, we know exactly which mouse events are bound and which
ones are not. To incorporate additional dependent functionality one event can
unbind and bind other events. For example, in either of the selection modes, the
code for moving segments should only be bound/active when there are segments
already selected. In this case, the mouseDown event binds the mouseMove event
after it has determined that the user has just clicked segment. 

Important files in the new setup are:
\begin{itemize}
    \item Editor.PermEvents.js This file contains events which are bound when
        Min starts and then left alone. This is where the events attached to the
        buttons on the top-bar are located.
    \item Editor.EditorMode.js This file contains code that will be used by
        all EditorModes. All *Mode style objects have an instance of this object
        at the top of their prototype chain.
    \item Editor.SelectionMode.js Both rectangle and stroke selection mode
        contain a lot of shared behavior. They do movement and resizes in
        exactly the same way, the only difference is how they select strokes.
        Events common to both is in this file. This is part of the prototype
        chain for selection modes.
    \item Editor.RectangleSelectionMode.js This contains code specific to
        rectangle selection. When a segment is selected, SelectionMode takes
        over.
    \item Editor.StrokeSelectionMode.js This contains code specific to stroke
        selection. When a segment is selected, the events in SelectionMode take
        over.
\end{itemize}

\subsection*{Other Changes}

One final change that I made during refactoring was the addition of the
Modernizr library. Modernizr is a library which runs when the document loads and
finds out what the capabilities of the browser are. Currently I only use it to
check for the touch-screen interface. Originally, we just checked the user-agent
string to see if it had the 'iPad' in it. Modernizer provides a consistent
interface for checking for touch-screen functionality.

\end{document}
